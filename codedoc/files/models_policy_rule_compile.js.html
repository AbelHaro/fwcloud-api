<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>models/policy/rule_compile.js - FWCloud API REST Documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://foswiki.soltecsis.com/codedoc/soltecsis-logo1.png" title="FWCloud API REST Documentation"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ClusterRouter.html">ClusterRouter</a></li>
                                <li><a href="../classes/CompileRouter.html">CompileRouter</a></li>
                                <li><a href="../classes/FirewallModel.html">FirewallModel</a></li>
                                <li><a href="../classes/FirewallRouter.html">FirewallRouter</a></li>
                                <li><a href="../classes/FwcloudModel.html">FwcloudModel</a></li>
                                <li><a href="../classes/FwcloudRouter.html">FwcloudRouter</a></li>
                                <li><a href="../classes/IpobjModel.html">IpobjModel</a></li>
                                <li><a href="../classes/IpobjsRouter.html">IpobjsRouter</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Cluster.html">Cluster</a></li>
                                <li><a href="../modules/Compile.html">Compile</a></li>
                                <li><a href="../modules/Firewall.html">Firewall</a></li>
                                <li><a href="../modules/FirewallExport.html">FirewallExport</a></li>
                                <li><a href="../modules/Fwcloud.html">Fwcloud</a></li>
                                <li><a href="../modules/Ipobjs.html">Ipobjs</a></li>
                                <li><a href="../modules/OpenVPN.html">OpenVPN</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: models/policy/rule_compile.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

//create object
var RuleCompileModel = {};

module.exports = RuleCompileModel;

/**
 * Property Model to manage Policy Data
 *
 * @property PolicyModel
 * @type ../../models/policy/policy_r
 */
var Policy_rModel = require(&#x27;../../models/policy/policy_r&#x27;);

/**
 * Property Model to manage Policy Compiled Data
 *
 * @property Policy_cModel
 * @type ../../models/policy_c
 */
var Policy_cModel = require(&#x27;../../models/policy/policy_c&#x27;);

/**
 * Property Logger to manage App logs
 *
 * @property logger
 * @type log4js/app
 *
 */
var logger = require(&#x27;log4js&#x27;).getLogger(&quot;compiler&quot;);


/**
 * Property Model to manage API RESPONSE data
 *
 * @property api_resp
 * @type ../../models/api_response
 *
 */
var api_resp = require(&#x27;../../utils/api_response&#x27;);

const POLICY_TYPE_INPUT = 1;
const POLICY_TYPE_OUTPUT = 2;
const POLICY_TYPE_FORWARD = 3;
const POLICY_TYPE_SNAT = 4;
const POLICY_TYPE_DNAT = 5;
const POLICY_TYPE = [&#x27;&#x27;, &#x27;INPUT&#x27;, &#x27;OUTPUT&#x27;, &#x27;FORWARD&#x27;];
const ACTION = [&#x27;&#x27;, &#x27;ACCEPT&#x27;, &#x27;DROP&#x27;, &#x27;REJECT&#x27;, &#x27;ACCOUNTING&#x27;];

/*----------------------------------------------------------------------------------------------------------------------*/
RuleCompileModel.pre_compile_sd = (dir, sd) =&gt; {
	var items = {
		&#x27;negate&#x27; : ((sd.length&gt;0) ? sd[0].negate : 0),
		&#x27;str&#x27;: []
	};

	for (var i = 0; i &lt; sd.length; i++) {
		if (sd[i].type === 5) // Address
			items.str.push(dir+sd[i].address);
		else if (sd[i].type === 7) // Network
			items.str.push(dir+sd[i].address+&quot;/&quot;+sd[i].netmask);
		else if (sd[i].type === 6) // Address range
			items.str.push((dir!==&quot;&quot; ? (&quot;-m iprange &quot;+(dir===&quot;-s &quot; ? &quot;--src-range &quot; : &quot;--dst-range &quot;)) : &quot; &quot;)+sd[i].range_start+&quot;-&quot;+sd[i].range_end);
	}

	return ((items.str.length&gt;0) ? items : null);
};
/*----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------*/
RuleCompileModel.pre_compile_if = (dir, ifs) =&gt; {
	var items = {
		&#x27;negate&#x27; : ((ifs.length&gt;0) ? ifs[0].negate : 0),
		&#x27;str&#x27;: []
	};

	for (var i = 0; i &lt; ifs.length; i++)
		items.str.push(dir+ifs[i].name);
	
	return ((items.str.length&gt;0) ? items : null);
};
/*----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------*/
// Agrupate services position by protocol number (TCP, UDP, ICMP, etc.) 
// Returns an array of strings with the services agrupated by protocol.
/*----------------------------------------------------------------------------------------------------------------------*/
RuleCompileModel.pre_compile_svc = (sep,svc) =&gt; {
	var items = {
		&#x27;negate&#x27; : ((svc.length&gt;0) ? svc[0].negate : 0),
		&#x27;str&#x27;: []
	};
	var tcp = udp = imcp = tmp = &quot;&quot;;
	
	for (var i = 0; i &lt; svc.length; i++) {
		switch (svc[i].protocol) { // PROTOCOL NUMBER
			case 6: // TCP
				const mask = svc[i].tcp_flags_mask;
			
				if (!mask || mask===0) { // No TCP flags.
					if (svc[i].source_port_end === 0) { // No source port.
						if (tcp)
							tcp += &quot;,&quot;;
						tcp += (svc[i].destination_port_start === svc[i].destination_port_end) ? svc[i].destination_port_start : (svc[i].destination_port_start + sep + svc[i].destination_port_end);
					} else {
						tmp = &quot;-p tcp --sport &quot; + ((svc[i].source_port_start === svc[i].source_port_end) ? svc[i].source_port_start : (svc[i].source_port_start + sep + svc[i].source_port_end));
						if (svc[i].destination_port_end !== 0)
							tmp += &quot; --dport &quot; + ((svc[i].destination_port_start === svc[i].destination_port_end) ? svc[i].destination_port_start : (svc[i].destination_port_start + sep + svc[i].destination_port_end));
						items.str.push(tmp);
					}
				}
				else { // Add the TCP flags.
					tmp = &quot;-p tcp&quot;;
					if (svc[i].source_port_end !== 0) // Exists source port
						tmp += &quot; --sport &quot; + ((svc[i].source_port_start === svc[i].source_port_end) ? svc[i].source_port_start : (svc[i].source_port_start + sep + svc[i].source_port_end));
					if (svc[i].destination_port_end !== 0) // Exists destination port
						tmp += &quot; --dport &quot; + ((svc[i].destination_port_start === svc[i].destination_port_end) ? svc[i].destination_port_start : (svc[i].destination_port_start + sep + svc[i].destination_port_end));
					tmp += &quot; --tcp-flags &quot;;

					// If all mask bits are set.
					if (mask === 0b00111111)
						tmp += &quot;ALL &quot;;
					else {
						// Compose the mask.
						if (mask &amp; 0b00000001) // URG
							tmp += &quot;URG,&quot;;
						if (mask &amp; 0b00000010) // ACK
							tmp += &quot;ACK,&quot;;
						if (mask &amp; 0b00000100) // PSH
							tmp += &quot;PSH,&quot;;
						if (mask &amp; 0b00001000) // RST
							tmp += &quot;RST,&quot;;
						if (mask &amp; 0b00010000) // SYN
							tmp += &quot;SYN,&quot;;
						if (mask &amp; 0b00100000) // FIN
							tmp += &quot;FIN,&quot;;
						tmp = tmp.replace(/.$/,&quot; &quot;);
					}

					// Compose the flags that must be set.
					const settings = svc[i].tcp_flags_settings;
					if (!settings || settings === 0)
						tmp += &quot; NONE&quot;;
					else {
						// Compose the mask.
						if (settings &amp; 0b00000001) // URG
							tmp += &quot;URG,&quot;;
						if (settings &amp; 0b00000010) // ACK
							tmp += &quot;ACK,&quot;;
						if (settings &amp; 0b00000100) // PSH
							tmp += &quot;PSH,&quot;;
						if (settings &amp; 0b00001000) // RST
							tmp += &quot;RST,&quot;;
						if (settings &amp; 0b00010000) // SYN
							tmp += &quot;SYN,&quot;;
						if (settings &amp; 0b00100000) // FIN
							tmp += &quot;FIN,&quot;;
						tmp = tmp.substring(0, tmp.length - 1);
					}

					items.str.push(tmp);
				}
				break;

			case 17: // UDP
				if (svc[i].source_port_end === 0) { // No source port.
					if (udp)
						udp += &quot;,&quot;;
					udp += (svc[i].destination_port_start === svc[i].destination_port_end) ? svc[i].destination_port_start : (svc[i].destination_port_start + sep + svc[i].destination_port_end);
				} else {
					tmp = &quot;-p udp --sport &quot; + ((svc[i].source_port_start === svc[i].source_port_end) ? svc[i].source_port_start : (svc[i].source_port_start + sep + svc[i].source_port_end));
					if (svc[i].destination_port_end !== 0)
						tmp += &quot; --dport &quot; + ((svc[i].destination_port_start === svc[i].destination_port_end) ? svc[i].destination_port_start : (svc[i].destination_port_start + sep + svc[i].destination_port_end));
					items.str.push(tmp);
				}
				break;

			case 1: // ICMP
				if (svc[i].icmp_type===-1 &amp;&amp; svc[i].icmp_code===-1) // Any ICMP
					items.str.push(&quot;-p icmp -m icmp --icmp-type any&quot;);
				else if (svc[i].icmp_type!==-1 &amp;&amp; svc[i].icmp_code===-1)
					items.str.push(&quot;-p icmp -m icmp --icmp-type &quot;+svc[i].icmp_type);
				else if (svc[i].icmp_type!==-1 &amp;&amp; svc[i].icmp_code!==-1)
					items.str.push(&quot;-p icmp -m icmp --icmp-type &quot;+svc[i].icmp_type+&quot;/&quot;+svc[i].icmp_code);
				break;

			default: // Other IP protocols.
				items.str.push(&quot;-p &quot;+svc[i].protocol);
				break;
		}
	}

	if (tcp) {
		if (sep===&quot;:&quot;)
			tcp = (tcp.indexOf(&quot;,&quot;) &gt; -1) ? (&quot;-p tcp -m multiport --dports &quot;+tcp) : (&quot;-p tcp --dport &quot;+tcp);
		items.str.push(tcp);
	}
	if (udp) {
		if (sep===&quot;:&quot;)
			udp = (udp.indexOf(&quot;,&quot;) &gt; -1) ? (&quot;-p udp -m multiport --dports &quot;+udp) : (&quot;-p udp --dport &quot;+udp);
		items.str.push(udp);
	}

	return ((items.str.length&gt;0) ? items : null);
};
/*----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------*/
// This function will return an array of arrays of strings. 
// Each array will contain the precompiled strings for the items of each rule position.
/*----------------------------------------------------------------------------------------------------------------------*/
RuleCompileModel.pre_compile = (data) =&gt; {
	var position_items = [];
	const policy_type = data[0].type;
	var items, src_position, dst_position, svc_position;
	var i, j, p;

	if (policy_type === POLICY_TYPE_FORWARD) { src_position=2; dst_position=3; svc_position=4;}
	else { src_position=1; dst_position=2; svc_position=3;}
	
	// Generate items strings for all the rule positions.
	// WARNING: The order of creation of the arrays is important for optimization!!!!
	// The positions first in the array will be used first in the conditions.
	// INTERFACE IN / OUT
	if (items=RuleCompileModel.pre_compile_if(((policy_type===POLICY_TYPE_OUTPUT || policy_type===POLICY_TYPE_SNAT) ? &quot;-o &quot; : &quot;-i &quot;), data[0].positions[0].position_objs)) position_items.push(items);
	// INTERFACE OUT
	if (policy_type===POLICY_TYPE_FORWARD &amp;&amp; (items=RuleCompileModel.pre_compile_if(&quot;-o &quot;, data[0].positions[1].position_objs))) position_items.push(items);
	// SERVICE
	if (items=RuleCompileModel.pre_compile_svc(&quot;:&quot;,data[0].positions[svc_position].position_objs)) position_items.push(items);
	// SOURCE
	if (items=RuleCompileModel.pre_compile_sd(&quot;-s &quot;, data[0].positions[src_position].position_objs)) position_items.push(items);
	// DESTINATION
	if (items=RuleCompileModel.pre_compile_sd(&quot;-d &quot;, data[0].positions[dst_position].position_objs)) position_items.push(items);

	// Order the resulting array by number of strings into each array.
	if (position_items.length &lt; 2) // Don&#x27;t need ordering.
		return position_items;
	for (i = 0; i &lt; position_items.length; i++) {
		for (p = i, j = i + 1; j &lt; position_items.length; j++) {
			if (position_items[j].str.length &lt; position_items[p].str.length)
				p = j;
		}
		tmp = position_items[i];
		position_items[i] = position_items[p];
		position_items[p] = tmp;
	}

	// If we have negated positions and not negated positions, then move the negated positions to the end of the array.
	if (position_items.length === 1) // Don&#x27;t need it.
		return position_items;
	
	var position_items_not_negate = [];
	var position_items_negate = [];
	for (i = 0; i &lt; position_items.length; i++) {
		// Is this position item is negated, search for the next one no negated.
		if (!(position_items[i].negate))
			position_items_not_negate.push(position_items[i]);
		else
			position_items_negate.push(position_items[i]);
	}

	return position_items_not_negate.concat(position_items_negate);
};
/*----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------*/
RuleCompileModel.nat_action = (policy_type,trans_addr,trans_port,callback) =&gt; {
  try {
		if (trans_addr.length&gt;1 || trans_port.length&gt;1) {
			callback({&quot;Msg&quot;: &quot;Translated fields must contain a maximum of one item.&quot;},null);			
			return null;
		}

		if (policy_type===POLICY_TYPE_SNAT &amp;&amp; trans_addr.length===0) {
			if (trans_port.length===0)
				return &quot;MASQUERADE&quot;;
			callback({&quot;Msg&quot;: &quot;For SNAT &#x27;Translated Service&#x27; must be empty if &#x27;Translated Source&#x27; is empty.&quot;},null);
			return null;
		}

		// For DNAT the translated destination is mandatory.
		if (policy_type===POLICY_TYPE_DNAT &amp;&amp; trans_addr.length===0) {
			callback({&quot;Msg&quot;: &quot;For DNAT &#x27;Translated Destination&#x27; is mandatory.&quot;},null);
			return null;
		}
	
		// Only TCP and UDP protocols are allowed for the translated service position.
		if (trans_port.length===1 &amp;&amp; trans_port[0].protocol!==6 &amp;&amp; trans_port[0].protocol!==17)
		{
			callback({&quot;Msg&quot;: &quot;For &#x27;Translated Service&#x27; only protocols TCP and UDP are allowed.&quot;},null);
			return null;
		}
	
		var action = &quot;&quot;;
		if (policy_type===POLICY_TYPE_SNAT)
			action = &quot;SNAT --to-source &quot;
		else
			action = &quot;DNAT --to-destination &quot;

		if (trans_addr.length === 1) 
			action += (RuleCompileModel.pre_compile_sd(&quot;&quot;,trans_addr)).str[0];
		if (trans_port.length === 1) 
			action += &quot;:&quot;+(RuleCompileModel.pre_compile_svc(&quot;-&quot;,trans_port)).str[0];

		return action;
  } catch (e) {        
		callback(e,null);
    return null;	
  }
};
/*----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------*/
/* Get  policy_r by id and  by Id */
/*----------------------------------------------------------------------------------------------------------------------*/
RuleCompileModel.rule_compile = (cloud, fw, type, rule, callback) =&gt; {        
	Policy_rModel.getPolicy_rs_type_full(cloud, fw, type, rule)
	.then(data =&gt; {
		if (!data) {
			callback({&quot;Msg&quot;: &quot;Rule data not found.&quot;},null);
			return;
		}

		const policy_type = data[0].type;
		if (!policy_type || 
				(policy_type!==POLICY_TYPE_INPUT &amp;&amp; policy_type!==POLICY_TYPE_OUTPUT &amp;&amp; policy_type!==POLICY_TYPE_FORWARD
				 &amp;&amp; policy_type!==POLICY_TYPE_SNAT &amp;&amp; policy_type!==POLICY_TYPE_DNAT)) {
			callback({&quot;Msg&quot;: &quot;Invalid policy type.&quot;},null);
			return;
		}

		var cs = &quot;$IPTABLES &quot;; // Compile string.
		var after_log_action = log_chain = acc_chain = cs_trail = statefull = table = action = &quot;&quot;;

		if (policy_type === 4) { // SNAT
			table = &quot;-t nat&quot;;
			cs += table+&quot; -A POSTROUTING &quot;;
			if (!(action=RuleCompileModel.nat_action(policy_type,data[0].positions[4].position_objs,data[0].positions[5].position_objs,callback)))
				return;
		}
		else if (policy_type === 5) { // DNAT
			table = &quot;-t nat&quot;;
			cs += table+&quot; -A PREROUTING &quot;;
			if (!(action=RuleCompileModel.nat_action(policy_type,data[0].positions[4].position_objs,data[0].positions[5].position_objs,callback)))
				return;
		}
		else { // Filter policy
			if (data.length != 1 || !(data[0].positions)
					|| !(data[0].positions[0].position_objs) || !(data[0].positions[1].position_objs) || !(data[0].positions[2].position_objs)
					|| (policy_type === POLICY_TYPE_FORWARD &amp;&amp; !(data[0].positions[3].position_objs))) {
				callback({&quot;Msg&quot;: &quot;Bad rule data.&quot;},null);
				return;
			}
			cs += &quot;-A &quot; + POLICY_TYPE[policy_type] + &quot; &quot;;
			action = ACTION[data[0].action];
			if (action===&quot;ACCEPT&quot;) {
				if (data[0].options &amp; 0x0001) // Statefull rule.
					statefull =&quot;-m state --state NEW &quot;;
				else if ((data[0].firewall_options &amp; 0x0001) &amp;&amp; !(data[0].options &amp; 0x0002)) // Statefull firewall and this rule is not stateless.
					statefull =&quot;-m state --state NEW &quot;;
			}
			else if (action===&quot;ACCOUNTING&quot;) {
				acc_chain = &quot;FWCRULE&quot;+rule+&quot;.ACC&quot;; 
				action = acc_chain; 
			}

			// If log all rules option is enabled or log option for this rule is enabled.
			if ((data[0].firewall_options &amp; 0x0010) || (data[0].options &amp; 0x0004)) {
				log_chain = &quot;FWCRULE&quot;+rule+&quot;.LOG&quot;;
				if (!acc_chain) {
					after_log_action = action;
					action = log_chain;
				} else
					after_log_action = &quot;RETURN&quot;;
			}		
		}

		cs_trail = statefull+&quot;-j &quot;+action+&quot;\n&quot;;
		
		const position_items = RuleCompileModel.pre_compile(data);
		
		// Rule compilation process.
		if (position_items.length === 0) // No conditions rule.
			cs += cs_trail;
		else if (position_items.length===1 &amp;&amp; !(position_items[0].negate)) { // One condition rule and no negated position.
			if (position_items[0].str.length === 1) // Only one item in the condition.
				cs += position_items[0].str[0] + &quot; &quot; + cs_trail;
			else { // Multiple items in the condition.
				var cs1 = cs;
				cs = &quot;&quot;;
				for (var i = 0; i &lt; position_items[0].str.length; i++)
					cs += cs1 + position_items[0].str[i] + &quot; &quot; + cs_trail;
			}
		} else { // Multiple condition rules or one condition rule with the condition (position) negated.
			for (var i = 0, j, chain_number = 1, chain_name = &quot;&quot;, chain_next = &quot;&quot;; i &lt; position_items.length; i++) {
				// We have the position_items array ordered by arrays length.
				if (position_items[i].str.length===1 &amp;&amp; !(position_items[i].negate))
					cs += position_items[i].str[0]+&quot; &quot;;
				else {
					chain_name = &quot;FWCRULE&quot;+rule+&quot;.CH&quot;+chain_number;
					// If we are in the first condition and it is not negated.
					if (i===0 &amp;&amp; !(position_items[i].negate)) {
						var cs1 = cs;
						cs = &quot;&quot;;
						for (var j = 0; j &lt; position_items[0].str.length; j++)
							cs += cs1+position_items[0].str[j]+((j &lt; (position_items[0].str.length - 1)) ? &quot; &quot;+statefull+&quot; -j &quot;+chain_name+&quot;\n&quot; : &quot; &quot;);
					} else {
						if (!(position_items[i].negate)) {
							// If we are at the end of the array, the next chain will be the rule action.
							chain_next = (i === ((position_items.length)-1)) ? action : &quot;FWCRULE&quot;+rule+&quot;.CH&quot;+(chain_number+1);
						} else { // If the position is negated.
							chain_next = &quot;RETURN&quot;;
						}

						cs = &quot;$IPTABLES &quot;+table+&quot; -N &quot;+chain_name+&quot;\n&quot;+cs+((chain_number === 1) ? statefull+&quot; -j &quot;+chain_name+&quot;\n&quot; : &quot;&quot;);
						for (j = 0; j &lt; position_items[i].str.length; j++) {
							cs += &quot;$IPTABLES &quot;+table+&quot; -A &quot;+chain_name+&quot; &quot;+position_items[i].str[j]+&quot; -j &quot;+chain_next+&quot;\n&quot;;
						}
						chain_number++;

						if (position_items[i].negate)
							cs += &quot;$IPTABLES &quot;+table+&quot; -A &quot;+chain_name+&quot; -j &quot;+((i === ((position_items.length)-1)) ? action : &quot;FWCRULE&quot;+rule+&quot;.CH&quot;+chain_number)+&quot;\n&quot;;
					}
				}
			}

			// If we have not used IPTABLES user defined chains.
			if (chain_number === 1)
				cs += cs_trail;
		}

		// If we are using UDP or TCP ports in translated service position for NAT rules, 
		// make sure that the -p tcp or -p udp is included in the compilation string.
		if ((policy_type===4 || policy_type===5) &amp;&amp; data[0].positions[5].position_objs.length===1) { // SNAT or DNAT
			var substr=&quot;&quot;;
			if (data[0].positions[5].position_objs[0].protocol===6) // TCP
			 	substr += &quot; -p tcp &quot;;
			else if (data[0].positions[5].position_objs[0].protocol===17) // UDP
				substr += &quot; -p udp &quot;;
				 
			if(cs.indexOf(substr) === -1) {
				if (policy_type===4)  // SNAT
					cs = cs.replace(/-A POSTROUTING/g,&quot;-A POSTROUTING&quot;+substr);
				else // DNAT
				  cs = cs.replace(/-A PREROUTING/g,&quot;-A PREROUTING&quot;+substr);
			}
		}

		// Accounting and logging is not allowed with SNAT and DNAT chains.
		if (policy_type!==4 &amp;&amp; policy_type!==5) {
			if (acc_chain) {
				cs = &quot;$IPTABLES -N &quot;+acc_chain+&quot;\n&quot; + &quot;$IPTABLES -A &quot;+acc_chain+&quot; -j &quot;+((log_chain) ? log_chain : &quot;RETURN&quot;)+&quot;\n&quot; + cs;
			}
			if (log_chain) {
				cs = &quot;$IPTABLES -N &quot;+log_chain+&quot;\n&quot; +
					&quot;$IPTABLES -A &quot;+log_chain+&quot; -m limit --limit 60/minute -j LOG --log-level info --log-prefix \&quot;RULE ID &quot;+rule+&quot; [&quot;+after_log_action+&quot;] \&quot;\n&quot; +
					&quot;$IPTABLES -A &quot;+log_chain+&quot; -j &quot;+after_log_action+&quot;\n&quot; + cs;
			}
		}

		// Apply rule only to the selected firewall.
		if (data[0].fw_apply_to &amp;&amp; data[0].firewall_name)
			cs = &quot;if [ \&quot;$HOSTNAME\&quot; = \&quot;&quot;+data[0].firewall_name+&quot;\&quot; ]; then\n&quot;+cs+&quot;fi\n&quot;;		
		
		cs = cs.replace(/  +/g,&#x27; &#x27;);

		//Save compilation
		var policy_cData = {
			rule: rule,
			firewall: fw,
			rule_compiled: cs,
			status_compiled: 1
		};

		Policy_cModel.insertPolicy_c(policy_cData, (error, data) =&gt; { 
			/* We don&#x27;t worry about if the rule compilation string is stored fine in the database. */ });

		callback(null,cs);
	})
	.catch(error =&gt; callback(error,null));
};
/*----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------*/
/* Get the rule compilation string or compile it if this string is not uptodate.
/*----------------------------------------------------------------------------------------------------------------------*/
RuleCompileModel.get = (cloud, fw, type, rule) =&gt; {
	return new Promise((resolve,reject) =&gt; { 
		Policy_cModel.getPolicy_c(cloud, fw, rule, (error, data) =&gt; {
			if (error) return reject(error);
			if (data &amp;&amp; data.length &gt; 0) {
				if (data[0].c_status_recompile === 0)
					resolve(data[0].c_compiled);
				else {
					RuleCompileModel.rule_compile(cloud, fw, type, rule, (error,data) =&gt; {
						if (error) return reject(error)
						resolve(data);
					});
				}
			}
			else
				resolve(&quot;&quot;);
		});
	});
};
/*----------------------------------------------------------------------------------------------------------------------*/

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
